<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxia de Amor para Ana</title>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Dancing+Script:wght@700&family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            color: white;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .message {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 32px;
            color: #ff4d88;
            font-family: 'Pacifico', cursive;
            text-shadow: 0 0 15px #ff4d88, 0 0 25px #ff4d88;
            z-index: 100;
            pointer-events: none;
            animation: pulse 3s infinite alternate;
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: #aabbcc;
            z-index: 100;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #fff;
            text-align: center;
            z-index: 1000;
        }
        
        .love-text {
            position: absolute;
            color: #ff9ac9;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 12px rgba(255, 105, 180, 0.9), 0 0 20px rgba(255, 105, 180, 0.6);
            pointer-events: none;
            z-index: 100;
            transform-origin: center;
            font-family: 'Dancing Script', cursive;
            opacity: 0;
            transition: opacity 0.8s ease, transform 0.8s ease;
            text-align: center;
            white-space: nowrap;
        }
        
        .discover-message {
            position: absolute;
            top: 70px;
            width: 100%;
            text-align: center;
            font-size: 18px;
            color: #aabbcc;
            font-family: 'Dancing Script', cursive;
            z-index: 100;
            opacity: 0.8;
            animation: fadeInOut 4s infinite alternate;
        }
        
        .zoom-indicator {
            position: absolute;
            right: 20px;
            bottom: 20px;
            color: #aabbcc;
            font-size: 14px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 10px;
            opacity: 0.7;
        }
        
        .music-player {
            position: absolute;
            left: 20px;
            bottom: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }
        
        .music-btn {
            background: none;
            border: none;
            color: #ff4d88;
            font-size: 24px;
            cursor: pointer;
            margin-right: 10px;
            transition: transform 0.3s ease;
        }
        
        .music-btn:hover {
            transform: scale(1.2);
        }
        
        .music-info {
            font-size: 14px;
            color: #aabbcc;
            max-width: 150px;
        }
        
        .volume-control {
            margin-left: 10px;
            display: flex;
            align-items: center;
        }
        
        .volume-slider {
            width: 80px;
            margin-left: 8px;
            -webkit-appearance: none;
            height: 4px;
            border-radius: 2px;
            background: #555;
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ff4d88;
            cursor: pointer;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-8px) rotate(3deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="message">Eres el centro de mi universo Ana</div>
        <div class="discover-message">Explora el universo para descubrir mensajes de amor</div>
        <canvas id="canvas"></canvas>
        <div class="instructions">Haz clic y arrastra para girar en 3D ‚Ä¢ Rueda del mouse para zoom</div>
        <div class="zoom-indicator">Zoom: 100%</div>
        
        <div class="music-player">
            <button class="music-btn" id="playPauseBtn">‚è∏Ô∏è</button>
            <div class="music-info">Keane - Somewhere Only We Know</div>
            <div class="volume-control">
                <span style="color: #aabbcc;">üîä</span>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="70">
            </div>
        </div>
        
        <div class="loading">Cargando galaxia de amor...</div>
        
        <!-- Reproductor de audio HTML5 (autoplay silencioso, enlace directo Dropbox dl=1) -->
        <audio id="backgroundMusic" loop autoplay muted>
            <source src="https://www.dropbox.com/scl/fi/ju447r9wmlj7r499nq42c/Keane-Somewhere-Only-We-Know-espa-ol-lyrics-_2_2.mp3?rlkey=dx6g00mnwmp3t46jml887ij49&st=b0ptd8bz&dl=1" type="audio/mpeg">
        </audio>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Variables principales
            let scene, camera, renderer, controls;
            let blackHole, accretionDisk;
            let starField;
            let loveTexts = [];
            let zoomIndicator;
            let backgroundMusic, playPauseBtn, volumeSlider;
            let isPlaying = false;
            
            // Mensajes de amor ampliados
            const loveMessages = [
                "Te amo", "Te quiero", "Me encantas", "Te adoro", 
                "Eres mi persona favorita", "Eres mi sue√±o", "Eres mi todo", 
                "Eres hermosa", "Eres √∫nica", "Eres especial", 
                "Eres incre√≠ble", "Eres perfecta", "Eres maravillosa", 
                "Eres mi sol", "Eres mi luz", "Eres mi alegr√≠a", 
                "Eres mi inspiraci√≥n", "Eres mi raz√≥n", "Eres mi destino", 
                "Eres mi felicidad", "Eres mi paz", "Eres mi vida", 
                "Eres mi amor", "Eres mi cielo", "Eres mi estrella", 
                "Eres mi universo", "Eres mi todo", "Eres mi pasi√≥n", 
                "Eres mi deseo", "Eres mi energ√≠a", "Eres mi fortuna", 
                "Eres mi complemento", "Eres mi media naranja", "Eres mi alma gemela", 
                "Eres mi complicidad", "Eres mi confidente", "Eres mi refugio", 
                "Eres mi hogar", "Eres mi ritmo", "Eres mi melod√≠a", 
                "Eres mi poes√≠a", "Eres mi arte", "Eres mi musa", 
                "Eres mi canci√≥n", "Eres mi baile", "Eres mi viaje", 
                "Eres mi aventura", "Eres mi descanso", "Eres mi norte", 
                "Eres mi sur", "Eres mi este", "Eres mi oeste", 
                "Eres mi d√≠a", "Eres mi noche", "Eres mi amanecer", 
                "Eres mi atardecer", "Eres mi verano", "Eres mi invierno", 
                "Eres mi primavera", "Eres mi oto√±o", "Eres mi risa", 
                "Eres mi llanto", "Eres mi silencio", "Eres mi voz", 
                "Eres mi fuerza", "Eres mi vulnerabilidad", "Eres mi certeza", 
                "Eres mi duda", "Eres mi quietud", "Eres mi movimiento", 
                "Eres mi paz", "Eres mi guerra", "Eres mi Yin", 
                "Eres mi Yang", "Eres mi equilibrio", "Eres mi caos", 
                "Eres mi comienzo", "Eres mi final", "Eres mi infinito", 
                "Eres mi eternidad", "Eres mi presente", "Eres mi futuro", 
                "Eres mi pasado", "Eres mi historia", "Eres mi realidad", 
                "Eres mi fantas√≠a", "Eres mi magia", "Eres mi milagro", 
                "Eres mi tesoro", "Eres mi regalo", "Eres mi bendici√≥n", 
                "Eres mi sonrisa", "Eres mi mirada", "Eres mi respiro", 
                "Eres mi latido", "Eres mi calor", "Eres mi fr√≠o", 
                "Eres mi fuego", "Eres mi agua", "Eres mi tierra", 
                "Eres mi aire", "Eres mi esencia", "Eres mi existencia"
            ];
            
            // Inicializar Three.js
            function init() {
                // Crear escena
                scene = new THREE.Scene();
                
                // Crear c√°mara
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 8;
                
                // Crear renderizador
                renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'), 
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000);
                
                // Configurar controles de √≥rbita para rotaci√≥n 3D completa
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                
                // Almacenar referencia al indicador de zoom
                zoomIndicator = document.querySelector('.zoom-indicator');
                
                // Configurar elementos de m√∫sica
                backgroundMusic = document.getElementById('backgroundMusic');
                playPauseBtn = document.getElementById('playPauseBtn');
                volumeSlider = document.getElementById('volumeSlider');
                
                // Ensure audio starts muted for autoplay policy and set initial volume from slider
                if (backgroundMusic) {
                    backgroundMusic.muted = true;
                    backgroundMusic.volume = (volumeSlider ? volumeSlider.value / 100 : 0.7);
                }
                
                // Ensure we unmute on first user interaction (works even if autoplay succeeded or failed)
                const activateAudio = function () {
                    if (backgroundMusic && backgroundMusic.muted) {
                        backgroundMusic.muted = false;
                        backgroundMusic.play().then(() => {
                            isPlaying = true;
                            if (playPauseBtn) playPauseBtn.innerHTML = '‚è∏Ô∏è';
                        }).catch(err => {
                            console.log("Error al reproducir tras interacci√≥n:", err);
                        });
                    }
                };
                document.addEventListener('click', activateAudio, { once: true });
                document.addEventListener('touchstart', activateAudio, { once: true });
                
                // Configurar eventos de m√∫sica
                if (playPauseBtn) playPauseBtn.addEventListener('click', togglePlayPause);
                if (volumeSlider) volumeSlider.addEventListener('input', setVolume);
                
                // Intentar reproducir autom√°ticamente (en silencio) - si el navegador lo permite
                setTimeout(() => {
                    if (backgroundMusic) {
                        backgroundMusic.play().then(() => {
                            isPlaying = true;
                            if (playPauseBtn) playPauseBtn.innerHTML = '‚è∏Ô∏è';
                        }).catch(error => {
                            console.log("La reproducci√≥n autom√°tica fall√≥:", error);
                            // Si falla, la interacci√≥n del usuario (click/touch) har√° play (ya registrado arriba)
                        });
                    }
                }, 1000);
                
                // Crear agujero negro 3D realista
                createRealisticBlackHole();
                
                // Crear disco de acreci√≥n realista
                createRealisticAccretionDisk();
                
                // Crear campo de estrellas
                createStarField();
                
                // Crear textos amorosos
                createLoveTexts();
                
                // Ocultar mensaje de carga
                const loadingEl = document.querySelector('.loading');
                if (loadingEl) loadingEl.style.display = 'none';
                
                // A√±adir luz ambiental para mejor visualizaci√≥n
                const ambientLight = new THREE.AmbientLight(0x333333);
                scene.add(ambientLight);
                
                // A√±adir luz direccional para efectos de realismo
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(5, 3, 5);
                scene.add(directionalLight);
                
                // Iniciar animaci√≥n
                animate();
                
                // Manejar redimensionado
                window.addEventListener('resize', onWindowResize);
            }
            
            // Funci√≥n para iniciar audio cuando el usuario interact√∫a
            function startAudioOnInteraction() {
                if (!backgroundMusic) return;
                backgroundMusic.play().then(() => {
                    isPlaying = true;
                    playPauseBtn.innerHTML = '‚è∏Ô∏è';
                }).catch(error => {
                    console.log("Error al reproducir audio despu√©s de la interacci√≥n:", error);
                });
            }
            
            // Funci√≥n para reproducir/pausar m√∫sica
            function togglePlayPause() {
                if (!backgroundMusic) return;
                if (isPlaying) {
                    backgroundMusic.pause();
                    playPauseBtn.innerHTML = '‚ñ∂Ô∏è';
                } else {
                    backgroundMusic.play();
                    playPauseBtn.innerHTML = '‚è∏Ô∏è';
                }
                isPlaying = !isPlaying;
            }
            
            // Funci√≥n para ajustar el volumen
            function setVolume() {
                if (!backgroundMusic) return;
                backgroundMusic.volume = volumeSlider.value / 100;
            }
            
            // Crear agujero negro 3D realista
            function createRealisticBlackHole() {
                // Esfera para el agujero negro con alta resoluci√≥n
                const geometry = new THREE.SphereGeometry(1, 64, 64);
                
                // Material con efecto de agujero negro realista
                const material = new THREE.MeshPhongMaterial({
                    color: 0x000000,
                    emissive: 0x220022,
                    specular: 0x330033,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.95
                });
                
                blackHole = new THREE.Mesh(geometry, material);
                scene.add(blackHole);
                
                // A√±adir efecto de distorsi√≥n gravitacional (corona)
                const coronaGeometry = new THREE.SphereGeometry(1.1, 64, 64);
                const coronaMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        intensity: { value: 2.0 },
                        time: { value: 0 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        uniform float intensity;
                        uniform float time;
                        
                        void main() {
                            // Efecto de distorsi√≥n en los bordes
                            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 3.0);
                            
                            // Efecto de ondas conc√©ntricas
                            float waves = sin((vUv.x * 10.0) + time) * 0.5 + 0.5;
                            
                            // Combinar efectos
                            float opacity = fresnel * intensity * (0.7 + 0.3 * waves);
                            
                            // Color rojizo/azulado como en im√°genes reales de agujeros negros
                            vec3 coronaColor = mix(vec3(0.3, 0.1, 0.5), vec3(0.5, 0.2, 0.6), waves);
                            
                            gl_FragColor = vec4(coronaColor, opacity * 0.8);
                        }
                    `,
                    transparent: true,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending
                });
                
                const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                scene.add(corona);
            }
            
            // Crear disco de acreci√≥n realista
            function createRealisticAccretionDisk() {
                // Disco principal con efecto de gas caliente
                const diskGeometry = new THREE.RingGeometry(1.2, 3.5, 128);
                
                const diskMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        innerRadius: { value: 1.2 },
                        outerRadius: { value: 3.5 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec2 vUv;
                        uniform float time;
                        uniform float innerRadius;
                        uniform float outerRadius;
                        
                        void main() {
                            // Calcular distancia desde el centro (0-1)
                            float radius = (vUv.x * (outerRadius - innerRadius) + innerRadius);
                            float normalizedRadius = (radius - innerRadius) / (outerRadius - innerRadius);
                            
                            // Crear bandas de color como en un disco real de acreci√≥n
                            vec3 color1 = vec3(0.8, 0.4, 0.2); // naranja
                            vec3 color2 = vec3(0.6, 0.2, 0.8); // p√∫rpura
                            vec3 color3 = vec3(0.2, 0.4, 0.9); // azul
                            
                            // Mezclar colores seg√∫n la distancia radial
                            vec3 finalColor;
                            if (normalizedRadius < 0.3) {
                                finalColor = mix(color1, color2, normalizedRadius / 0.3);
                            } else if (normalizedRadius < 0.7) {
                                finalColor = mix(color2, color3, (normalizedRadius - 0.3) / 0.4);
                            } else {
                                finalColor = color3;
                            }
                            
                            // A√±adir variaci√≥n temporal para efecto de plasma
                            float timeVariation = sin(time * 0.5 + normalizedRadius * 10.0) * 0.5 + 0.5;
                            finalColor *= (0.8 + 0.2 * timeVariation);
                            
                            // Hacer el disco m√°s transparente en los bordes
                            float alpha = 1.0 - smoothstep(0.7, 1.0, normalizedRadius);
                            alpha *= 0.9;
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                
                accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
                accretionDisk.rotation.x = Math.PI / 2;
                scene.add(accretionDisk);
                
                // Disco interior m√°s caliente y brillante
                const innerDiskGeometry = new THREE.RingGeometry(1.1, 1.8, 64);
                const innerDiskMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec2 vUv;
                        uniform float time;
                        
                        void main() {
                            // Efecto de plasma muy caliente en el disco interior
                            float intensity = sin(time * 2.0 + vUv.x * 20.0) * 0.5 + 0.5;
                            
                            // Colores c√°lidos para representar alta temperatura
                            vec3 hotColor = mix(vec3(1.0, 0.9, 0.5), vec3(1.0, 0.5, 0.2), intensity);
                            
                            // Variaci√≥n radial de opacidad
                            float alpha = 1.0 - smoothstep(0.0, 1.0, vUv.x);
                            alpha *= 0.9;
                            
                            gl_FragColor = vec4(hotColor, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                
                const innerDisk = new THREE.Mesh(innerDiskGeometry, innerDiskMaterial);
                innerDisk.rotation.x = Math.PI / 2;
                scene.add(innerDisk);
            }
            
            // Crear campo de estrellas
            function createStarField() {
                const starGeometry = new THREE.BufferGeometry();
                const starMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.1,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                const starVertices = [];
                for (let i = 0; i < 15000; i++) {
                    const x = (Math.random() - 0.5) * 2500;
                    const y = (Math.random() - 0.5) * 2500;
                    const z = (Math.random() - 0.5) * 2500;
                    starVertices.push(x, y, z);
                }
                
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                starField = new THREE.Points(starGeometry, starMaterial);
                scene.add(starField);
            }
            
            // Crear textos amorosos con distribuci√≥n amplia
            function createLoveTexts() {
                const textContainer = document.body;
                
                loveMessages.forEach((msg, index) => {
                    const textElement = document.createElement('div');
                    textElement.className = 'love-text';
                    textElement.textContent = msg;
                    textElement.style.animation = `float ${8 + Math.random() * 8}s infinite ease-in-out`;
                    textElement.style.animationDelay = `${Math.random() * 5}s`;
                    
                    // Asignar una fuente aleatoria para variedad
                    const fonts = ['Dancing Script', 'Pacifico', 'Great Vibes', 'cursive'];
                    textElement.style.fontFamily = fonts[Math.floor(Math.random() * fonts.length)];
                    
                    // Tama√±o aleatorio para variedad
                    const baseSize = 28;
                    const sizeVariation = Math.random() * 12;
                    textElement.style.fontSize = `${baseSize + sizeVariation}px`;
                    
                    textContainer.appendChild(textElement);
                    
                    // Posicionar en un volumen amplio alrededor del agujero negro
                    // Usar diferentes capas de distancia para distribuir mejor los textos
                    const layer = Math.floor(index / 30); // 30 textos por capa
                    const distance = 5 + (layer * 8) + (Math.random() * 6);
                    
                    // √Ångulos aleatorios para distribuci√≥n esf√©rica
                    const phi = Math.acos(-1 + (2 * (index % 30)) / 30);
                    const theta = Math.sqrt(30 * Math.PI) * phi;
                    
                    const x = distance * Math.cos(theta) * Math.sin(phi);
                    const y = distance * Math.sin(theta) * Math.sin(phi);
                    const z = distance * Math.cos(phi);
                    
                    // A√±adir variaci√≥n aleatoria adicional para evitar patrones regulares
                    const variation = 2;
                    loveTexts.push({
                        element: textElement,
                        position: new THREE.Vector3(
                            x + (Math.random() - 0.5) * variation,
                            y + (Math.random() - 0.5) * variation,
                            z + (Math.random() - 0.5) * variation
                        ),
                        size: parseFloat(textElement.style.fontSize),
                        visible: false
                    });
                });
            }
            
            // Actualizar posici√≥n de textos en la pantalla
            function updateTextPositions() {
                const cameraDistance = camera.position.length();
                const zoomLevel = Math.max(10, Math.min(200, Math.round(1000 / cameraDistance)));
                zoomIndicator.textContent = `Zoom: ${zoomLevel}%`;
                
                loveTexts.forEach(text => {
                    const vector = text.position.clone();
                    
                    // Proyectar la posici√≥n 3D a 2D
                    vector.project(camera);
                    
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                    
                    // Calcular la distancia entre la c√°mara y el texto
                    const textDistance = text.position.distanceTo(camera.position);
                    
                    // Solo mostrar textos que est√°n frente a la c√°mara
                    if (vector.z < 1) {
                        text.element.style.display = 'block';
                        text.element.style.left = `${x}px`;
                        text.element.style.top = `${y}px`;
                        
                        // Ajustar tama√±o basado en la distancia para mantener legibilidad
                        const scale = Math.max(0.3, Math.min(2, 15 / textDistance));
                        text.element.style.transform = `scale(${scale})`;
                        
                        // Ajustar opacidad seg√∫n la distancia - requiere zoom para ver los textos
                        let opacity = 0;
                        if (textDistance < 15) {
                            opacity = Math.max(0.3, Math.min(1, (15 - textDistance) / 10));
                        }
                        
                        text.element.style.opacity = opacity;
                        
                        // Marcar como visible si est√° lo suficientemente cerca
                        text.visible = (textDistance < 20);
                    } else {
                        text.element.style.display = 'none';
                        text.visible = false;
                    }
                });
                
                // Actualizar mensaje de descubrimiento
                const visibleTexts = loveTexts.filter(text => text.visible).length;
                const discoverMessage = document.querySelector('.discover-message');
                
                if (visibleTexts === 0) {
                    discoverMessage.textContent = "Explora el universo para descubrir mensajes de amor";
                } else if (visibleTexts < 5) {
                    discoverMessage.textContent = `Has encontrado ${visibleTexts} mensaje${visibleTexts !== 1 ? 's' : ''} de amor`;
                } else {
                    discoverMessage.textContent = `¬°Wow! Has descubierto ${visibleTexts} mensajes de amor`;
                }
            }
            
            // Manejar redimensionado de ventana
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                updateTextPositions();
            }
            
            // Animaci√≥n
            function animate() {
                requestAnimationFrame(animate);
                
                // Actualizar tiempo para shaders
                try {
                    if (accretionDisk && accretionDisk.material && accretionDisk.material.uniforms && accretionDisk.material.uniforms.time) {
                        accretionDisk.material.uniforms.time.value += 0.01;
                    }
                } catch (e) {
                    // ignore
                }
                
                // Rotar el disco de acreci√≥n
                if (accretionDisk) {
                    accretionDisk.rotation.z += 0.002;
                }
                
                // Actualizar posici√≥n de textos
                updateTextPositions();
                
                // Actualizar controles
                if (controls) controls.update();
                
                // Renderizar escena
                if (renderer && scene && camera) renderer.render(scene, camera);
            }
            
            // Iniciar
            init();
        });
    </script>
</body>
</html>





