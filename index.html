<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Galaxia de Amor para Ana</title>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Dancing+Script:wght@700&family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            color: white;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container { position: relative; width: 100%; height: 100%; }

        /* Canvas ocupa todo el contenedor */
        #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        .message {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 32px;
            color: #ff4d88;
            font-family: 'Pacifico', cursive;
            text-shadow: 0 0 15px #ff4d88, 0 0 25px #ff4d88;
            z-index: 100;
            pointer-events: none;
            animation: pulse 3s infinite alternate;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: #aabbcc;
            z-index: 100;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #fff;
            text-align: center;
            z-index: 1000;
            pointer-events: none;
        }

        .love-text {
            position: absolute;
            color: #ff9ac9;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 12px rgba(255, 105, 180, 0.9), 0 0 20px rgba(255, 105, 180, 0.6);
            pointer-events: none;
            z-index: 100;
            transform-origin: center;
            font-family: 'Dancing Script', cursive;
            opacity: 0;
            transition: opacity 0.8s ease, transform 0.8s ease;
            text-align: center;
            white-space: nowrap;
            will-change: transform, opacity;
        }

        .discover-message {
            position: absolute;
            top: 70px;
            width: 100%;
            text-align: center;
            font-size: 18px;
            color: #aabbcc;
            font-family: 'Dancing Script', cursive;
            z-index: 100;
            opacity: 0.8;
            animation: fadeInOut 4s infinite alternate;
        }

        .zoom-indicator {
            position: absolute;
            right: 20px;
            bottom: 20px;
            color: #aabbcc;
            font-size: 14px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 10px;
            opacity: 0.7;
        }

        .music-player {
            position: absolute;
            left: 20px;
            bottom: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        .music-btn {
            background: none;
            border: none;
            color: #ff4d88;
            font-size: 24px;
            cursor: pointer;
            margin-right: 10px;
            transition: transform 0.3s ease;
        }

        .music-btn:hover { transform: scale(1.2); }

        .music-info { font-size: 14px; color: #aabbcc; max-width: 150px; }

        .volume-control { margin-left: 10px; display: flex; align-items: center; }

        .volume-slider {
            width: 80px;
            margin-left: 8px;
            -webkit-appearance: none;
            height: 4px;
            border-radius: 2px;
            background: #555;
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ff4d88;
            cursor: pointer;
        }

        @keyframes pulse { 0% { transform: scale(1); } 100% { transform: scale(1.05); } }
        @keyframes fadeInOut { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
        @keyframes float { 0%, 100% { transform: translateY(0) rotate(0deg); } 50% { transform: translateY(-8px) rotate(3deg); } }

        /* Responsive tweaks to keep layout balanced on small screens */
        @media (max-width: 700px) {
            .message { font-size: 24px; top: 12px; }
            .discover-message { top: 52px; font-size: 16px; }
            .zoom-indicator { right: 10px; bottom: 10px; font-size: 12px; }
            .music-player { left: 10px; bottom: 10px; padding: 8px 12px; }
            .instructions { bottom: 12px; font-size: 13px; }
            .love-text { font-size: 20px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="message">Eres el centro de mi universo Ana</div>
        <div class="discover-message">Explora el universo para descubrir mensajes de amor</div>
        <canvas id="canvas"></canvas>
        <div class="instructions">Haz clic y arrastra para girar en 3D ‚Ä¢ Rueda del mouse para zoom</div>
        <div class="zoom-indicator">Zoom: 100%</div>

        <div class="music-player">
            <button class="music-btn" id="playPauseBtn">‚è∏Ô∏è</button>
            <div class="music-info">Keane - Somewhere Only We Know</div>
            <div class="volume-control">
                <span style="color: #aabbcc;">üîä</span>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="70">
            </div>
        </div>

        <div class="loading" id="loading">Cargando galaxia de amor...</div>

        <!-- Reproductor de audio HTML5 (autoplay silencioso, enlace directo Dropbox dl=1) -->
        <audio id="backgroundMusic" loop autoplay muted>
            <source src="https://www.dropbox.com/scl/fi/ju447r9wmlj7r499nq42c/Keane-Somewhere-Only-We-Know-espa-ol-lyrics-_2_2.mp3?rlkey=dx6g00mnwmp3t46jml887ij49&st=b0ptd8bz&dl=1" type="audio/mpeg">
        </audio>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Detecci√≥n simple de m√≥vil para optimizaciones
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 760;

        // Variables principales (id√©nticas a las tuyas)
        let scene, camera, renderer, controls;
        let blackHole, accretionDisk;
        let starField;
        let loveTexts = [];
        let zoomIndicator;
        let backgroundMusic, playPauseBtn, volumeSlider;
        let isPlaying = false;

        // Mensajes (los tuyos, inalterados)
        const loveMessages = [
            "Te amo", "Te quiero", "Me encantas", "Te adoro", 
            "Eres mi persona favorita", "Eres mi sue√±o", "Eres mi todo", 
            "Eres hermosa", "Eres √∫nica", "Eres especial", 
            "Eres incre√≠ble", "Eres perfecta", "Eres maravillosa", 
            "Eres mi sol", "Eres mi luz", "Eres mi alegr√≠a", 
            "Eres mi inspiraci√≥n", "Eres mi raz√≥n", "Eres mi destino", 
            "Eres mi felicidad", "Eres mi paz", "Eres mi vida", 
            "Eres mi amor", "Eres mi cielo", "Eres mi estrella", 
            "Eres mi universo", "Eres mi todo", "Eres mi pasi√≥n", 
            "Eres mi deseo", "Eres mi energ√≠a", "Eres mi fortuna", 
            "Eres mi complemento", "Eres mi media naranja", "Eres mi alma gemela", 
            "Eres mi complicidad", "Eres mi confidente", "Eres mi refugio", 
            "Eres mi hogar", "Eres mi ritmo", "Eres mi melod√≠a", 
            "Eres mi poes√≠a", "Eres mi arte", "Eres mi musa", 
            "Eres mi canci√≥n", "Eres mi baile", "Eres mi viaje", 
            "Eres mi aventura", "Eres mi descanso", "Eres mi norte", 
            "Eres mi sur", "Eres mi este", "Eres mi oeste", 
            "Eres mi d√≠a", "Eres mi noche", "Eres mi amanecer", 
            "Eres mi atardecer", "Eres mi verano", "Eres mi invierno", 
            "Eres mi primavera", "Eres mi oto√±o", "Eres mi risa", 
            "Eres mi llanto", "Eres mi silencio", "Eres mi voz", 
            "Eres mi fuerza", "Eres mi vulnerabilidad", "Eres mi certeza", 
            "Eres mi duda", "Eres mi quietud", "Eres mi movimiento", 
            "Eres mi paz", "Eres mi guerra", "Eres mi Yin", 
            "Eres mi Yang", "Eres mi equilibrio", "Eres mi caos", 
            "Eres mi comienzo", "Eres mi final", "Eres mi infinito", 
            "Eres mi eternidad", "Eres mi presente", "Eres mi futuro", 
            "Eres mi pasado", "Eres mi historia", "Eres mi realidad", 
            "Eres mi fantas√≠a", "Eres mi magia", "Eres mi milagro", 
            "Eres mi tesoro", "Eres mi regalo", "Eres mi bendici√≥n", 
            "Eres mi sonrisa", "Eres mi mirada", "Eres mi respiro", 
            "Eres mi latido", "Eres mi calor", "Eres mi fr√≠o", 
            "Eres mi fuego", "Eres mi agua", "Eres mi tierra", 
            "Eres mi aire", "Eres mi esencia", "Eres mi existencia"
        ];

        // Lista reducida para m√≥viles (menos DOM)
        const loveMessagesMobile = loveMessages.slice(0, 40); // primeros 40 en m√≥vil

        // Inicializar Three.js
        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });

            // Limitar devicePixelRatio para no forzar m√≥viles de forma innecesaria
            const DPR = Math.min(window.devicePixelRatio || 1, 2);
            renderer.setPixelRatio(DPR);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);

            // Controles (t√°ctiles incluidos)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = isMobile ? 0.6 : 1.0; // velocidad m√°s baja en m√≥vil
            controls.zoomSpeed = isMobile ? 0.8 : 1.2;
            controls.enablePan = false;

            zoomIndicator = document.querySelector('.zoom-indicator');

            // M√∫sica y controles UI
            backgroundMusic = document.getElementById('backgroundMusic');
            playPauseBtn = document.getElementById('playPauseBtn');
            volumeSlider = document.getElementById('volumeSlider');

            // Inicializa audio seguro
            if (backgroundMusic) {
                backgroundMusic.muted = true; // autoplay policy
                backgroundMusic.volume = (volumeSlider ? volumeSlider.value / 100 : 0.7);
                // set preload to auto for better loading
                backgroundMusic.preload = 'auto';
            }

            // Registra listeners de audio (play/pause/volume)
            if (playPauseBtn) playPauseBtn.addEventListener('click', togglePlayPause, { passive: true });
            if (volumeSlider) volumeSlider.addEventListener('input', setVolume, { passive: true });

            // Desmutear al primer click/touch (cumple pol√≠tica autoplay)
            const activateAudio = function () {
                if (backgroundMusic && backgroundMusic.muted) {
                    backgroundMusic.muted = false;
                    backgroundMusic.play().then(() => {
                        isPlaying = true;
                        if (playPauseBtn) playPauseBtn.innerHTML = '‚è∏Ô∏è';
                    }).catch(err => {
                        // no hacemos nada si falla, ser√° manejado por play/pause
                        console.log("Error al reproducir tras interacci√≥n:", err);
                    });
                }
            };
            document.addEventListener('click', activateAudio, { once: true, passive: true });
            document.addEventListener('touchstart', activateAudio, { once: true, passive: true });

            // Intentar autoplay silencioso (alg√∫n navegador lo permitir√°)
            setTimeout(() => {
                if (backgroundMusic) {
                    backgroundMusic.play().then(() => {
                        isPlaying = true;
                        if (playPauseBtn) playPauseBtn.innerHTML = '‚è∏Ô∏è';
                    }).catch(error => {
                        // Normal: NotAllowedError si no hubo interacci√≥n
                        console.log("La reproducci√≥n autom√°tica fall√≥:", error);
                    });
                }
            }, 500);

            // Crear escena: agujero negro, disco, estrellas y textos
            createRealisticBlackHole();
            createRealisticAccretionDisk();
            createStarField();
            createLoveTexts();

            // Hide loading when scene ready (brief pause to allow assets)
            setTimeout(() => {
                const loadingEl = document.querySelector('.loading');
                if (loadingEl) loadingEl.style.display = 'none';
            }, 1200);

            // Luces
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            // Resize with debounce (mejor rendimiento)
            let resizeTimeout = null;
            window.addEventListener('resize', () => {
                if (resizeTimeout) clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(onWindowResize, 120);
            }, { passive: true });

            // Start animation
            animate();
        }

        // Toggle play/pause
        function togglePlayPause () {
            if (!backgroundMusic) return;
            if (isPlaying) {
                backgroundMusic.pause();
                playPauseBtn.innerHTML = '‚ñ∂Ô∏è';
            } else {
                backgroundMusic.play();
                playPauseBtn.innerHTML = '‚è∏Ô∏è';
            }
            isPlaying = !isPlaying;
        }

        function setVolume () {
            if (!backgroundMusic) return;
            backgroundMusic.volume = volumeSlider.value / 100;
        }

        // Crear agujero negro (igual que tu original)
        function createRealisticBlackHole() {
            const geometry = new THREE.SphereGeometry(1, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x000000,
                emissive: 0x220022,
                specular: 0x330033,
                shininess: 100,
                transparent: true,
                opacity: 0.95
            });
            blackHole = new THREE.Mesh(geometry, material);
            scene.add(blackHole);

            const coronaGeometry = new THREE.SphereGeometry(1.1, 64, 64);
            const coronaMaterial = new THREE.ShaderMaterial({
                uniforms: { intensity: { value: 2.0 }, time: { value: 0 } },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    uniform float intensity;
                    uniform float time;
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0,0.0,1.0))), 3.0);
                        float waves = sin((vUv.x * 10.0) + time) * 0.5 + 0.5;
                        float opacity = fresnel * intensity * (0.7 + 0.3 * waves);
                        vec3 coronaColor = mix(vec3(0.3,0.1,0.5), vec3(0.5,0.2,0.6), waves);
                        gl_FragColor = vec4(coronaColor, opacity * 0.8);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            scene.add(corona);
        }

        // Crear disco de acreci√≥n (igual que tu original)
        function createRealisticAccretionDisk() {
            const diskGeometry = new THREE.RingGeometry(1.2, 3.5, 128);
            const diskMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, innerRadius: { value: 1.2 }, outerRadius: { value: 3.5 } },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    uniform float time;
                    uniform float innerRadius;
                    uniform float outerRadius;
                    void main() {
                        float radius = (vUv.x * (outerRadius - innerRadius) + innerRadius);
                        float normalizedRadius = (radius - innerRadius) / (outerRadius - innerRadius);
                        vec3 color1 = vec3(0.8,0.4,0.2);
                        vec3 color2 = vec3(0.6,0.2,0.8);
                        vec3 color3 = vec3(0.2,0.4,0.9);
                        vec3 finalColor;
                        if (normalizedRadius < 0.3) {
                            finalColor = mix(color1, color2, normalizedRadius / 0.3);
                        } else if (normalizedRadius < 0.7) {
                            finalColor = mix(color2, color3, (normalizedRadius - 0.3) / 0.4);
                        } else {
                            finalColor = color3;
                        }
                        float timeVariation = sin(time * 0.5 + normalizedRadius * 10.0) * 0.5 + 0.5;
                        finalColor *= (0.8 + 0.2 * timeVariation);
                        float alpha = 1.0 - smoothstep(0.7, 1.0, normalizedRadius);
                        alpha *= 0.9;
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
            accretionDisk.rotation.x = Math.PI/2;
            scene.add(accretionDisk);

            const innerDiskGeometry = new THREE.RingGeometry(1.1, 1.8, 64);
            const innerDiskMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    uniform float time;
                    void main() {
                        float intensity = sin(time * 2.0 + vUv.x * 20.0) * 0.5 + 0.5;
                        vec3 hotColor = mix(vec3(1.0,0.9,0.5), vec3(1.0,0.5,0.2), intensity);
                        float alpha = 1.0 - smoothstep(0.0, 1.0, vUv.x);
                        alpha *= 0.9;
                        gl_FragColor = vec4(hotColor, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const innerDisk = new THREE.Mesh(innerDiskGeometry, innerDiskMaterial);
            innerDisk.rotation.x = Math.PI/2;
            scene.add(innerDisk);
        }

        // Crear campo de estrellas (reducido en m√≥vil)
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            // Ajuste: menos estrellas para m√≥vil
            const count = isMobile ? 4500 : 15000;
            const starVertices = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                starVertices[i*3] = (Math.random() - 0.5) * 2500;
                starVertices[i*3 + 1] = (Math.random() - 0.5) * 2500;
                starVertices[i*3 + 2] = (Math.random() - 0.5) * 2500;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: isMobile ? 0.08 : 0.1, transparent: true, blending: THREE.AdditiveBlending });
            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        // Crear textos amorosos (limitar en m√≥vil para menos DOM)
        function createLoveTexts() {
            const textContainer = document.body;
            const msgs = isMobile ? loveMessagesMobile : loveMessages;
            loveTexts = [];

            msgs.forEach((msg, index) => {
                const textElement = document.createElement('div');
                textElement.className = 'love-text';
                textElement.textContent = msg;
                textElement.style.animation = `float ${8 + Math.random() * 8}s infinite ease-in-out`;
                textElement.style.animationDelay = `${Math.random() * 5}s`;

                // Mantener tus fuentes
                const fonts = ['Dancing Script', 'Pacifico', 'Great Vibes', 'cursive'];
                textElement.style.fontFamily = fonts[Math.floor(Math.random() * fonts.length)];

                // Tama√±o aleatorio
                const baseSize = isMobile ? 20 : 28;
                const sizeVariation = Math.random() * (isMobile ? 8 : 12);
                textElement.style.fontSize = `${baseSize + sizeVariation}px`;

                textContainer.appendChild(textElement);

                // Distribuci√≥n en capas esf√©ricas (tu algoritmo original)
                const layer = Math.floor(index / 30);
                const distance = 5 + (layer * 8) + (Math.random() * 6);
                const phi = Math.acos(-1 + (2 * (index % 30)) / 30);
                const theta = Math.sqrt(30 * Math.PI) * phi;

                const x = distance * Math.cos(theta) * Math.sin(phi);
                const y = distance * Math.sin(theta) * Math.sin(phi);
                const z = distance * Math.cos(phi);

                const variation = 2;
                loveTexts.push({
                    element: textElement,
                    position: new THREE.Vector3(
                        x + (Math.random() - 0.5) * variation,
                        y + (Math.random() - 0.5) * variation,
                        z + (Math.random() - 0.5) * variation
                    ),
                    size: parseFloat(textElement.style.fontSize),
                    visible: false
                });
            });
        }

        // Actualizar posiciones 2D de textos (optimizado)
        function updateTextPositions() {
            if (!camera) return;
            const cameraDistance = camera.position.length();
            const zoomLevel = Math.max(10, Math.min(200, Math.round(1000 / cameraDistance)));
            if (zoomIndicator) zoomIndicator.textContent = `Zoom: ${zoomLevel}%`;

            // Loop simple, evitar layout thrashing: set styles in variables then apply
            for (let i = 0; i < loveTexts.length; i++) {
                const text = loveTexts[i];
                const vector = text.position.clone();
                vector.project(camera);
                // outside near plane skip
                if (vector.z >= 1) {
                    if (text.element.style.display !== 'none') text.element.style.display = 'none';
                    text.visible = false;
                    continue;
                }
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                const textDistance = text.position.distanceTo(camera.position);
                // scale & opacity
                const scale = Math.max(0.3, Math.min(2, 15 / textDistance));
                let opacity = 0;
                if (textDistance < 15) {
                    opacity = Math.max(0.3, Math.min(1, (15 - textDistance) / 10));
                }

                // Apply styles
                const el = text.element;
                el.style.display = 'block';
                el.style.left = `${x}px`;
                el.style.top = `${y}px`;
                el.style.transform = `translate(-50%, -50%) scale(${scale})`;
                el.style.opacity = opacity;
                text.visible = (textDistance < 20);
            }

            // Update discover-message
            const visibleTexts = loveTexts.filter(t => t.visible).length;
            const discoverMessage = document.querySelector('.discover-message');
            if (discoverMessage) {
                if (visibleTexts === 0) {
                    discoverMessage.textContent = "Explora el universo para descubrir mensajes de amor";
                } else if (visibleTexts < 5) {
                    discoverMessage.textContent = `Has encontrado ${visibleTexts} mensaje${visibleTexts !== 1 ? 's' : ''} de amor`;
                } else {
                    discoverMessage.textContent = `¬°Wow! Has descubierto ${visibleTexts} mensajes de amor`;
                }
            }
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateTextPositions();
        }

        // Animaci√≥n principal (optimizado)
        function animate() {
            requestAnimationFrame(animate);

            // actualizar tiempo en shaders si existe
            try {
                if (accretionDisk && accretionDisk.material && accretionDisk.material.uniforms && accretionDisk.material.uniforms.time) {
                    accretionDisk.material.uniforms.time.value += 0.01;
                }
            } catch (e) {}

            if (accretionDisk) accretionDisk.rotation.z += isMobile ? 0.0015 : 0.002;
            if (starField) starField.rotation.y += isMobile ? 0.0003 : 0.0005;

            updateTextPositions();
            if (controls) controls.update();
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        // Inicializar todo
        init();
    });
    </script>
</body>
</html>

